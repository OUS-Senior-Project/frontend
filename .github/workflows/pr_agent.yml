name: PR Agent

on:
  issue_comment:
    types: [created, edited]

concurrency:
  group: pr-agent-${{ github.event.issue.number || github.ref }}
  cancel-in-progress: true

jobs:
  pr_agent_job:
    # Only run when a human comments /review on a PR
    if: >-
      github.event.sender.type != 'Bot' &&
      github.event.issue.pull_request &&
      startsWith(github.event.comment.body, '/review')
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      issues: write
      pull-requests: write
      contents: read

    steps:
      - name: Run PR-Agent
        id: pragent
        uses: qodo-ai/pr-agent@v0.32
        env:
          OPENAI_KEY: ${{ secrets.OPENAI_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

          # Use a supported OpenAI model for PR-Agent
          "config.model": "gpt-5-nano"
          "config.fallback_models": "[\"gpt-5\"]"

          # We publish our own normalized comment
          "config.publish_output": "false"
          "config.publish_output_progress": "false"

          # Keep JSON output so we can format it ourselves
          "github_action_config.enable_output": "true"

          # Manual /review only
          "github_action_config.auto_review": "false"
          "github_action_config.auto_describe": "false"
          "github_action_config.auto_improve": "false"

      - name: Post normalized PR review comment
        if: >-
          always() &&
          steps.pragent.outputs.review != ''
        continue-on-error: true
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        env:
          PR_REVIEW_JSON: ${{ steps.pragent.outputs.review }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const marker = '<!-- pr-agent-normalized-verdict -->';

            function collectStrings(node, acc = []) {
              if (node == null) return acc;
              if (typeof node === 'string') acc.push(node);
              else if (Array.isArray(node)) node.forEach(v => collectStrings(v, acc));
              else if (typeof node === 'object') Object.values(node).forEach(v => collectStrings(v, acc));
              return acc;
            }

            function extractFindings(node, acc = []) {
              if (node == null) return acc;
              if (Array.isArray(node)) {
                for (const item of node) extractFindings(item, acc);
                return acc;
              }
              if (typeof node !== 'object') return acc;

              const maybeFinding =
                ('issue_header' in node) ||
                ('issue_content' in node) ||
                ('relevant_file' in node) ||
                ('file' in node && ('title' in node || 'content' in node));

              if (maybeFinding) acc.push(node);

              for (const value of Object.values(node)) extractFindings(value, acc);
              return acc;
            }

            function clean(s) {
              if (!s) return '';
              return String(s)
                .replace(/\r/g, '')
                .replace(/<br\s*\/?>/gi, '\n')
                .replace(/<\/?[^>]+>/g, '')
                .replace(/\n{3,}/g, '\n\n')
                .trim();
            }

            function toFinding(obj) {
              const title = clean(obj.issue_header || obj.title || obj.header || obj.name || '');
              const body  = clean(obj.issue_content || obj.content || obj.description || obj.details || '');
              const file  = clean(obj.relevant_file || obj.file_path || obj.filename || obj.file || '');

              const joined = `${title}\n${body}`;
              let severity = 'NIT';
              if (/\[BLOCKER\]/i.test(joined)) severity = 'BLOCKER';
              else if (/\[NIT\]/i.test(joined)) severity = 'NIT';

              return {
                severity,
                title: (title || 'Issue found').replace(/\[(BLOCKER|NIT)\]\s*/ig, '').trim(),
                body: (body || '').replace(/\[(BLOCKER|NIT)\]\s*/ig, '').trim(),
                file,
              };
            }

            function uniqueFindings(findings) {
              const seen = new Set();
              const out = [];
              for (const f of findings) {
                const key = `${f.severity}||${f.file}||${f.title}||${f.body}`;
                if (seen.has(key)) continue;
                seen.add(key);
                out.push(f);
              }
              return out;
            }

            function sanitizeForTextFence(s) {
              // Prevent accidental fence breaks if model outputs triple backticks
              return String(s || '').replace(/```/g, '```\\u200b');
            }

            function formatFindingBullet(f) {
              const firstLine = f.file ? `- **${f.file}** â€” ${f.title}` : `- ${f.title}`;
              if (!f.body) return firstLine;
              const indented = f.body.split('\n').map(line => `  ${line}`).join('\n');
              return `${firstLine}\n${indented}`;
            }

            const raw = process.env.PR_REVIEW_JSON;
            if (!raw || !raw.trim()) {
              core.notice('No PR-Agent review JSON output found.');
              return;
            }

            let reviewObj;
            try {
              reviewObj = JSON.parse(raw);
            } catch (e) {
              core.warning(`Failed to parse PR review JSON: ${e.message}`);
              return;
            }

            const allText = collectStrings(reviewObj).join('\n');

            // Accept explicit verdict with or without markdown bold:
            // VERDICT: APPROVE
            // VERDICT: **APPROVE**
            let verdict = null;
            const verdictMatch = allText.match(
              /\b(?:VERDICT|Verdict):\s*(?:\*\*)?\s*(APPROVE WITH NITS|APPROVE|REQUEST_CHANGES)\s*(?:\*\*)?\b/i
            );
            if (verdictMatch) verdict = verdictMatch[1].toUpperCase();

            let findings = uniqueFindings(extractFindings(reviewObj).map(toFinding))
              .filter(f => f.title || f.body || f.file);

            const blockers = findings.filter(f => f.severity === 'BLOCKER');
            const nits = findings.filter(f => f.severity !== 'BLOCKER');

            // Deterministic fallback verdict if explicit verdict is absent
            if (!verdict) {
              if (blockers.length > 0) verdict = 'REQUEST_CHANGES';
              else if (findings.length > 0) verdict = 'APPROVE WITH NITS';
              else verdict = 'APPROVE';
            }

            // Build the exact COMMENT TO LEAVE text (inside ```text fence)
            const commentLines = [];

            commentLines.push('### Summary');
            if (verdict === 'REQUEST_CHANGES') {
              commentLines.push('- Changes are required before approval based on the issues identified in the PR diff review.');
            } else if (verdict === 'APPROVE WITH NITS') {
              commentLines.push('- Core changes look acceptable, but there are non-blocking improvements worth addressing.');
            } else {
              commentLines.push('- No significant issues were identified in the reviewed PR diff context.');
            }
            commentLines.push('');

            if (blockers.length > 0) {
              commentLines.push('### Blocking issues');
              blockers.forEach(f => commentLines.push(formatFindingBullet(f)));
              commentLines.push('');
            }

            if (nits.length > 0) {
              commentLines.push('### Non-blocking notes');
              nits.forEach(f => commentLines.push(formatFindingBullet(f)));
              commentLines.push('');
            }

            commentLines.push('### What I checked');
            commentLines.push('- PR-Agent review output for the current PR diff (normalized from `steps.pragent.outputs.review`).');
            commentLines.push('- Runtime/build/test execution is only referenced if present in the PR-Agent output context.');

            const commentsToLeaveText = sanitizeForTextFence(commentLines.join('\n').trim());

            // EXACT visible format requested
            const body = [
              `VERDICT: **${verdict}**`,
              `COMMENT TO LEAVE:`,
              '',
              '```text',
              commentsToLeaveText,
              '```',
              '',
              marker,
              `<!-- pr-agent-normalized-verdict:${verdict} -->`
            ].join('\n');

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.payload.issue?.number;

            if (!issue_number) {
              core.notice('No issue number found; skipping comment.');
              return;
            }

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number,
              per_page: 100
            });

            const existing = comments.find(c =>
              c.user?.type === 'Bot' &&
              c.user?.login === 'github-actions[bot]' &&
              typeof c.body === 'string' &&
              c.body.includes(marker)
            );

            if (existing) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: existing.id,
                body
              });
              core.info(`Updated existing normalized comment (${existing.id}).`);
            } else {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body
              });
              core.info('Created normalized comment.');
            }